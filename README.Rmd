---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# RTransferEntropy

The goal of `RTransferEntropy` is to implement the calculation of the transfer entropy metric using Shannon's or the Renyi's methodology.

## Installation

You can install `RTransferEntropy` with
```{r, eval = FALSE}
install.packages("RTransferEntropy")
```

or the development version from github with

```{r gh_installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("BZPaper/RTransferEntropy")
```

## Example using simulated data

Simulate a simple model to obtain two time series that are not independent (see simulation study in Dimpfl and Peter (2013)),
i.e. one time series is lag of the other plus noise. In this case, one expects significant information flow from x to y 
and none from y to x.

### Simulating a Time-Series
```{r}
library(RTransferEntropy)
library(future)
# enable parallel processing
plan(multiprocess)

set.seed(20180108)
n <- 2000
x <- rep(0, n + 1)
y <- rep(0, n + 1)

for (i in seq(n)) {
  x[i + 1] <- 0.2 * x[i] + rnorm(1, 0, 2)
  y[i + 1] <- x[i] + rnorm(1, 0, 2)
}

x <- x[-1]
y <- y[-1]
```


### Visualisation
```{r contemp_plot, message=FALSE, warning=FALSE}
library(ggplot2)
theme_set(theme_light())

dt <- do.call(rbind, list(
  data.frame(x = x, y = y, dir = "Level-Level", stringsAsFactors = FALSE),
  data.frame(x = x, y = c(NA, y[1:(length(y) - 1)]), dir = "Lag Y\nY->X", stringsAsFactors = FALSE),
  data.frame(x = c(NA, x[1:(length(x) - 1)]), y = y, dir = "Lag X\nX->Y", stringsAsFactors = FALSE)
))
dt$dir <- factor(dt$dir, levels = c("Lag X\nX->Y", "Level-Level", "Lag Y\nY->X"))


ggplot(dt, aes(x = x, y = y)) + 
  geom_smooth() +
  geom_point(alpha = 0.5, size = 0.5) +
  facet_grid(~dir) +
  theme_light() +
  labs(title = "X-Y Relations for Different Lags") +
  coord_fixed(ratio = 1)
```

### Shannon Transfer Entropy
```{r}
set.seed(20180108 + 1)

shannon_te <- transfer_entropy(x = x, y = y)

shannon_te
```

Alternatively, you can calculate only the transfer entropy or the effective transfer entropy with
```{r}
calc_te(x, y)
calc_te(y, x)

calc_ete(x, y)
calc_ete(y, x)
```


### Renyi Transfer Entropy
```{r}
set.seed(20180108 + 1)

renyi_te <- transfer_entropy(x = x, y = y, entropy = "renyi", q = 0.5)

renyi_te

calc_te(x, y, entropy = "renyi", q = 0.5)
calc_te(y, x, entropy = "renyi", q = 0.5)

calc_ete(x, y, entropy = "renyi", q = 0.5)
calc_ete(y, x, entropy = "renyi", q = 0.5)
```

# Function Verbosity aka `quiet = TRUE`

To disable the verbosity of a function you can use the argument `quiet`. Note that we have set `nboot = 0` as we don't need bootstrapped quantiles for this example.
```{r}
te_s <- transfer_entropy(x, y, nboot = 0, quiet = T)

te_s
```

If you want to disable feedback from `transfer_entropy` functions, you can do so by using `set_quiet(TRUE)`
```{r}
set_quiet(TRUE)
te_s <- transfer_entropy(x, y, nboot = 0)
te_r <- transfer_entropy(x, y, entropy = "renyi", nboot = 0)

te_s
te_r

# revert back with
set_quiet(FALSE)
te_s <- transfer_entropy(x, y, nboot = 0)
```

# Parallel Programming

Using the `future` package and its `plan`s we can execute all computations in parallel like so
```{r, warning=F}
library(future)
plan(multiprocess)
te_s <- transfer_entropy(x, y, nboot = 100)
te_r <- transfer_entropy(x, y, entropy = "renyi", nboot = 100)

# revert to sequential mode
plan(sequential)
te_s <- transfer_entropy(x, y, nboot = 100)
```
